<!DOCTYPE html>
<html>
<!-- Note to self: Use pre tag to share preformatted code (code snippets)-->

<head>
  <title>Shawn Blakesley WebGL Shader</title>

  <!-- Include Three.js (TODO: need to change this to a local copy)-->
  <script type="text/javascript" src="/js/three.min.js"></script>
  <script type="text/javascript" src="/js/OrbitControls.js"></script>
  <!-- Dat Gui for controlling the shaders demo-->
  <script type="text/javascript" src="/js/dat.gui.min.js"></script>
  <!-- Teapot geometry from Udacity's Interactive 3D Graphics Course -->
  <script type="text/javascript" src="/js/uclass_TeapotGeometry.js"></script>

  <!--Shaders for toon shading based loosly off udacity course lectures for interactive 3d graphics-->
  <script type="x-shader/x-vertex" id="toon_shader_vertex">
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    varying vec3 surfacePos;

    void main() {
      surfacePos = position;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      vNormal = normalize( normalMatrix * normal );
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vViewPosition = -mvPosition.xyz;
    }
  </script>
  <script type="x-shader/x-fragment" id="toon_shader_fragment">
    uniform vec3 uMaterialColor;
    uniform vec3 uDirLightPos;
    uniform vec3 uDirLightColor;

    uniform vec3 uPrimaryColor;
    uniform vec3 uSecondaryColor;

    uniform float uBorder;
    uniform float uCheckerSize;
    uniform float uShine;

    varying vec3 vNormal;
    varying vec3 vViewPosition;
    varying vec3 surfacePos;

    void main() {
      vec3 position = surfacePos / uCheckerSize;
      vec3 color = uMaterialColor;
      if(fract(position.x) < 0.5 && fract(position.z) < 0.5){
        color *= uPrimaryColor;
      }
      else if(fract(position.z) < 0.5){
        color *= uSecondaryColor;
      }
      else if(fract(position.x) < 0.5)
      {
        color *= 0.01;
      }
      else{
        color *= 0.01;
      }
      // compute direction to light
      vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );
      vec3 lVector = normalize( lDirection.xyz );

      // diffuse: N * L. Normal must be normalized, since it's interpolated.
      vec3 normal = normalize( vNormal );
      
      float diffuse = dot( normal, lVector );
      //Specular highlighting
      vec3 eye = vec3(0,0,1);
      vec3 H = normalize(lVector + eye);
      float specular = max(0.0, dot(normal, H));
      float shine = uShine * 195.0 + 5.0;
      specular = pow(specular, shine);
      specular = step(0.5, specular);
      //Create a cartoon look with 3 intensities
      diffuse = diffuse > uBorder ? 1.0 : diffuse > uBorder - 0.2 ? 0.4 : 0.1;
      gl_FragColor = vec4( color * uDirLightColor * diffuse + color * specular, 1.0 );
      //gl_FragColor = vec4( color * uDirLightColor * diffuse, 1.0 );
    }
  </script>

  <!--Placeholder shaders-->
  <script type="x-shader/x-vertex" id="placeholder_shader_vertex">
    void main()
    {
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
  </script>
  <script type="x-shader/x-fragment" id="placeholder_shader_fragment">
    void main()
    {
      gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );
    }
  </script>
</head>

<body style="background:black;">
  <!-- WebGL Shader -->
  <div id="shader-controls" style="position: absolute;"></div>
  <div id="shader"></div>
  <script src="/js/shaders.js"></script>
</body>

</html>